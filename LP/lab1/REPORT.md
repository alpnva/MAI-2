# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Алапанова Э.Х.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|  20.12       |      4        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в языке Пролог похож на связный список в принятых императивных языках программирования. Самым главным отличием является выделение в списке начала и хвоста в языке Пролог. Если сравнивать с такими языками программирования, как C/C++ или Java, в которых в списке могут храниться только элементы одного типа, то Пролог дает возможность использовать разные элементы. А все операции над списками производятся рекурсивно.
## Задание 1.1: Предикат обработки списка

`delete_n(X, N, Y), delete_2(0, L, L)` - удаление N первых элементов.

Примеры использования:
```prolog
test :-
    Test = [1,2,4,8,16],
    delete_n(1, Test, X1),
    write(X1), nl.
?-test.
[2, 4, 8, 16]
Yes.
test1:-
    delete_n2(3, [1,2,3,6,7], X1),
    write(X1), nl.
?-test1.
[6,7]
Yes.
```

Реализация:
```prolog
% Без стандартных предикатов
delete_n2(0, L, L).
delete_n2(_, [], []).
delete_n2(N, [_|T1], L2):- N > 0, N1 is N-1, delete_n2(N1, T1, L2).
% Со стандартным предикатом
delete_n(X, N, Y):- append(A, X, Y), length(A, N).
```
Предикат без стандартных предикатов
Сначала определяем предикат при удалении 0 элементов, в этом случае список L также останется списком L. Затем рекурсивно определяем предикат для N элементов. Значит, удалить из списка c концом T1 N элементов, это то же самое, что удалить из списка T1 N1 элементов, причем N1 должно быть равно N-1.

Предикат с использованием стандартных предикатов:
С помощью предиката `append` рассматриваем все возможности разбиения списка, а с помощью предиката `length` находим разбиение нужной длины и отсекаем его, затем выводим оставшийся список.

## Задание 1.2: Предикат обработки числового списка

`lincompare([], []), lincompare2([X|Tail], [Y|Tail])` - лексиграфическое сравнение двух списков.

Примеры использования:
```prolog
?- lincompare([1,2,3,50], [5,2,3,50]).
No.
?- lincompare([1,2,3,50], [1,2,3,50]).
Yes.
?- lincompare2([1,2,3,50], [1,2,3,50]).
Yes.
?- lincompare2([1,2,3,50], [1,2,3]).
No.
```

Реализация:
```prolog
%Без стандартных предикатов
lincompare2([X|Tail], [Y|Tail]):- X =:= Y, lincompare2(Tail, Tail).
lincompare2([X], [Y]):- X =:= Y.
%Со стандартным предикатом
lincompare([], []).
lincompare([X|Tail], Y):- remove(Y, X, Y1), lincompare(Tail, Y1).
```
Предикат без стандартных предикатов
Определяем предикат с двумя списками. Затем отделяем голову, сравниваем их, и если они равны, то список уменьшается, затем идем далее. 

Предикат с использованием стандартных предикатов
Сначала определяем предикат с двумя списками на входе. Затем с помощью предиката `remove` удаляем одинаковые элементы и дальше рекурсивно сравниваем.

## Задание 2: Реляционное представление данных

Преимуществами реляционного представления данных является то, что все данные задаются в виде отношений, т.е. информация хранится в удобной форме, которую довольно легка для понимания человеком. Тем самым можно  строгой математической форме описать обработку данных.
А недостатком является скорость доступа к данным, так как реляционное представление данных занимает достаточно большой объем внешней памяти. Если у нас будет слишком много данных, это может привести к появлению очень большого количества таблиц, что приведет непонимаю данной нам информации. Также иногда представление не всегда может быть удобным для работы с такими данными.

В варианте реляционного представления `two.pl` информация представлялась так: `grade(Group, Student, Subject, Mark)`. Т.е. данные хранятся в виде фактов, в которых хранятся данные о группе, студенте, предмете и оценке за этот предмет. Преимуществом является то, что все данные представлены одним предикатом. Однако это занимает довольно много места, информация о том, что студент учится в какой-то группе было повторено множество раз.

Чтобы использовать предикаты из файла, сначала импортируем его:
``` prolog
:-['two.pl'].
```

1. Напечатать средний балл для каждого предмета:
``` prolog
task1() :-
    findall(A, grade(_, _, A, _), S1),
    setof(A, member(A, S1), S),
    printsrball(S).
```
Мы генерируем список предметов и с помощью следующего предиката `printsrball` печатаем средние баллы. А список всех предметов можно получить комбинацией `findall` и `setof`.
Но для этого сначала напишем вспомогательный предикат для получения на вход список предметов, для каждого из которых предикат напечатаем средний балл:
``` prolog
printsrball([A|B]) :-
    srball(A, X), write(A), write(': '), write(X), nl, printsrball(B).
printsrball([]).
```
Также нам понадобится предикат вычисления среднего балла для одного предмета:
``` prolog
sum([A|B], Sum) :- 
    sum(B, Sum1), Sum is A + Sum1.
sum([], 0).

% Средний балл по предмету
srball(A, Answ) :-
    findall(X, grade(_, _, A, X), B),
    sum(B, Sum), length(B, Len), Answ is Sum / Len.
```
Результат:
``` prolog
Английский язык: 3.75
Информатика: 3.9285714285714284
Логическое программирование: 3.9642857142857144
Математический анализ: 3.892857142857143
Психология: 3.9285714285714284
Функциональное программирование: 3.9642857142857144
true
```

2. Для каждой группы, найти количество не сдавших студентов:
``` prolog
task2() :-
    findall(A, grade(A, _, _, _), S1),
    setof(A, member(A, S1), S),
    printfailed(S).
```
Изначально реализуем предикат, который находит число несдавших студентов в группе:
``` prolog
failed(S, M) :-
    findall(A, grade(S, A, _, 2), L),
    length(L, M).
```
Затем печатаем число несдавших студентов для группы из списка:
``` prolog
printfailed([A|X]) :-
    failed(A, B), write(A), write(': '), write(B), nl, printfailed(X).
printfailed([]).
```
Результат:
``` prolog
101: 2
102: 5
103: 4
104: 2
true
```
3. Найти количество не сдавших студентов для каждого из предметов:
``` prolog
task3() :-
    findall(A, grade(_, _, A, _), S1),
    setof(A, member(A, S1), S),
    printfailedsubj(S).
```
Сначала нам нужно число несдавших предмет студентов:
``` prolog
failedsubj(S, M) :-
    findall(A, grade(_, A, S, 2), L),
    length(L, M).
```
И также распечатка числа несдавших студентов для предмета из списка:
``` prolog
printfailedsubj([A|X]) :-
    failedsubj(A, B), write(A), write(': '), write(B), nl, printfailedsubj(X).
printfailedsubj([]).
```
Результат:
``` prolog
Английский язык: 4
Информатика: 2
Логическое программирование: 2
Математический анализ: 3
Психология: 1
Функциональное программирование: 1
true
```

## Выводы

Данная лабораторная работа научила меня основам логического программирования и работе со списками и реляционными представлениями данных. Это мой первый опыт в написании программы на языке Пролог, самое интересное, что нужно мыслить совсем иначе, нежели при написании на императивных языках. 
Однако, чтобы писать на Прологе, нужно больше практики, здесь нужно использовать именно логическое мышление. Решения задач немного нетривиальные, поэтому нужно больше времени, чтобы посидеть разобраться со всем этим. 
Также я научилась создавать предикаты для решения простейших задач на языке Пролог, такими как обработка списков и работа с данными в реляционном представлении. Думаю, данная работа даст нам базу для решения более сложных заданий в будущем. 
Я не уверена, понадобится ли мне где-то язык Пролог вне программы курса, но это будет хороший опыт в написании программы не на таком привычном императивном языке.
