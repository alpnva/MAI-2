# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: <Алапанова Эльза Халилевна>

## Результат проверки

Вариант задания:

 - [x] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |     3.5          |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

При выполнении данного курсового проекта я получу навыки обработки данных в формате GEDCOM. Это довольно интересный тип данных, если в будущем мне снова нужно будет обрабатывать генеалогическое древо, то я буду уже знать, какова их структура хранения и как можно это преобразовать в нужный мне формат. Вспомню Python для работы с файлами, а именно со строками. Пойму как работать с родословным деревом, чтобы описать, кто кому кем является.


## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате [GEDCOM](https://ru.wikipedia.org/wiki/GEDCOM). Для этого использую сервис [MyHeritage.com](http://myheritage.com).

 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: 
    3. с использованием предиката `child(ребенок, родитель)`, `male(человек)`, `female(человек)`.

 3. Реализовать предикат проверки/поиска:
     4. Двоюродный брат.
    
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве.
 5. [На более чем удовлетворительную оценку] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.

## Получение родословного дерева

Я получила родословное дерево при помощи сервиса [MyHeritage.com](http://myheritage.com). Сначала прописала своих родственников, всего их получилось 30 индивидуумов. Затем экспортировала древо с помощью встроенных функций данного сервиса, тем самым получила дерево в формате [GEDCOM](https://ru.wikipedia.org/wiki/GEDCOM).

## Конвертация родословного дерева

Для конвертации родословного дерева в формате [GEDCOM] в факты языка Prolog я использовала Python. Я выбрала этот язык, потому что он удобен в работе со строками. Мне нужно было вывести факты о женщинах, мужчинах и детях. Изначально выводятся факты о мужчине, а остальные запоминались программой. 
Если программа встречает нового человека, то запоминаем его ID. Строка с именем помечается ключевым словом  "NAME", с полом - "SEX". 
``` python
 if "INDI" in line:  # для нахождения человека
        ID = line[5:10]
    elif "NAME" in line:
        name = line[7:-1]
        person[ID] = "'" + name[:-1][:-1] + "'"
```
Для определения ребенка строка помечается ключевым словом "CHIL", а родители "HUSB" и "WIFE". Из-за неполноты дерева, некоторых супругов может не быть, тогда их имена будут помечаться пустыми строками. 

## Предикат поиска родственника

Согласно варианту, мне нужно реализовать предикат по поиску двоюродного брата. Для этого сначала я реализую предикат по установлению прямого родства.
Предикат siblings проверяет, есть ли общие родители у двух человек и имеет проверку не один и тот же ли этот человек.
``` prolog
siblings(X, Y):-  % выясняем, являются ли родными братьями/сестрами
    child(X, Rod),
    child(Y, Rod),
    male(Rod), 
    X\=Y.
```
Далее предикат cousin, который выполняет поиск двоюродного брата. 
``` prolog
cousin(X, Y):- % проверка на двоюродного брата
    child(X, P),
    siblings(P, PP),
    child(Y, PP),
    male(Y).
```
Сначала он проверяет, есть ли у родителей ребенка родные братья/сестры, затем он ищет его/ее детей, также предикат проверяет, чтобы этот ребенок был мужского пола.
Пример реализации:
``` prolog
3 ?- cousin('Эльза Алапанова', X).
X = 'Газинур Алапанов' ;
X = 'Ралис Амиров' ;
false.
```
Как видим, Prolog выдал нам имена двух двоюродных братьев Алапановой Эльзы.
## Определение степени родства

Изначально описываем предикаты родства. 
``` prolog
% son(parent, son)
son(A, B) :- 
    male(B), child(B, A).

% daughter(parent, daughter)
daughter(A, B) :- 
    female(B), child(B, A).

% mother (child, mother)
mother(A, B) :-
    female(B), child(A, B).

% father (child, father)
father(A, B) :-
    male(B), child(A, B).

% grandmother(person, grandmother)
grandmother(A, B) :- 
    child(A, C), mother(C, B).

% grandfather(person, grandfather)
grandfather(A, B) :- 
    child(A, C), father(C, B).

% brother(person, brother).
brother(A, B) :- 
    male(B), child(B, C), 
    child(A, C), A \= B.

% sister(person, sister).
sister(A, B) :- 
    female(B), child(B, C), 
    child(A, C), A \= B.

% wife(husband, wife)
wife(A, B) :-  
    male(A), female(B), 
    child(C, A), child(C, B).

% husband(wife, husband)
husband(A, B) :- wife(B, A).

% mother_in_law(man, his mother in law)
mother_in_law(A, B) :- 
    male(A), female(B), 
    wife(A, C), child(C, B).

% father_in_law(man, his father in law)
father_in_law(A, B) :- 
    male(A), female(B), 
    husband(A, C), child(C, B).
```
Затем расписала итеартивный поиск с такими путями отношений:
``` prolog
% движения для алгоритма поиска
move(A, B, grandson) :- 
    grandson(A, B).
move(A, B, granddaughter) :- 
    granddaughter(A, B).
move(A, B, grandfather ):- 
    grandfather(A, B).
move(A, B, grandmother) :- 
    grandmother(A, B).
move(A, B, father_in_law) :- 
    father_in_law(A, B).
move(A, B, mother_in_law) :- 
    mother_in_law(A, B).
move(A, B, father):-
    father(A, B).
move(A, B, mother) :-
    mother(A, B).
move(A, B, son) :-
    son(A, B).
move(A, B, daughter) :-
    daughter(A, B).
move(A, B, brother) :-
    brother(A, B).
move(A, B, sister) :-
    sister(A, B).
move(A, B, husband) :- 
    husband(A, B).
move(A, B, wife):- 
    wife(A, B).

% итерационный поиск

int(1).
int(M) :-
	int(N),
	M is N+1.

search([Now|T1], Now, [Now|T1], [], 1). 
search([Now|T1], Final, Way, [R|T2], N) :-
	N > 0,
	move(Now, New, R),
	not(member(New, [Now|T1])),
	N1 is N-1,
	search([New, Now|T1], Final, Way, T2, N1).

iter_search(Start, Final, Way, R) :-
	int(M),
	(M > 50, !;	
    search([Start], Final, Way, R, M)).

% Определение степени родства
relatives(A, B, Ans):-
	iter_search(A, B, _, Ans),!.
```
Результат работы предиката:
``` prolog
?- relatives('София Рангулова', 'Хазира', Way).
Way = [grandmother].

?- relatives('Эльза Алапанова', 'Ралис Амиров', Way).
Way = [grandfather, grandson].

?- relatives('Ирина Байсикина', 'Сахия', Way).
Way = [grandfather, grandfather, mother].
```
## Выводы

На самом деле было интересно определять родство через такой язык программирования как Prolog. Курсовая работа заставила задуматься, что нужно больше изучать своих предков и чтить память о них, ведь сейчас есть столько классных возможностей это все записать и передавать это дело дальше. 
Я достигла всех целей: изучила принципы работы языка Prolog, чуть глубже познакомилась с разными алгоритмами. 
В этой работе и вправду лучше всего использовать Prolog, так как удобно обрабатывать списка, графы, вычислять предикаты и на их основе составлять целые базы. Немного необычно было настроиться на другой ход мышления, нежели в императивных языках программирования. Опыт написания данной курсовой работы будет очень полезным в рамках всеобщего развития. 
