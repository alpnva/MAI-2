#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Алапанова Э.Х.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   22/12      |        5      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Метод поиска в пространстве состояний используется в разных задачах, и необходимо грамотно подбирать нужный нам метод, чтобы решить ту или иную задачу. Но наиболее удобным этот метод будет в задачах, где присутствует дискретное множество состояний, в которых может находиться определённый объект или система, с правилами и условиями перехода из одного состояния в другое. 
В прологе удобно решать такого рода задачи, как в моем варианте, потому что пролог генерирует граф состояний, что позволяет поиску работать с графами неогранниченного размера.

## Задание

Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром.

## Принцип решения

Для решения нашей задачи понадобятся 3 вещи: условия нахождения шаров, предикаты для разных ситуаций и предикат поиска. Затем мы задаем начальное и конечное состояние, тем самым программа ищет пути решения нашей задачи. ф
Изначально напишем предикат добавления элемента к списку `append([], X, X).`:
```prolog
append([], X, X).
append([A|B], X, [A|C]) :- 
    append(B, X, C).
```
Затем напишем предикаты для разных ситуаций (меняем местами черные и белые шары):
```prolog
change(X,Y) :- 
    append(Head, ['_','w'|Tail], X), append(Head, ['w','_'|Tail], Y).
change(X,Y) :- 
    append(Head, ['w','_'|Tail], X), append(Head, ['_','w'|Tail], Y).
change(X,Y) :- 
    append(Head, ['_','b'|Tail], X), append(Head, ['b','_'|Tail], Y).
change(X,Y) :- 
    append(Head, ['b','_'|Tail], X), append(Head, ['_','b'|Tail], Y).
change(X,Y) :- 
    append(Head, ['_','b','w'|Tail], X), append(Head, ['w','b','_'|Tail], Y).
change(X,Y) :- 
    append(Head, ['_','w','b'|Tail], X), append(Head, ['b','w','_'|Tail], Y).
change(X,Y) :- 
    append(Head, ['b','w','_'|Tail], X), append(Head, ['_','w','b'|Tail], Y).
change(X,Y) :- 
    append(Head, ['w','b','_'|Tail], X), append(Head, ['_','b','w'|Tail], Y).
```
Поиск в глубину: 
```prolog
search_in_depth(A, B) :- 
    write(A), depth([[A]], B, C), print(C), !.
depth([[X|Y]|_], X, [X|Y]).
depth([X|Y], A, C) :- 
    findall(D, prolonged(X, D), B), append(B, Y, F), !, depth(F, A, C).
depth([_,Y], A, B) :- 
    depth(Y, A, B).
```
Поиск в ширину:
```prolog
search_in_width(A, B) :- 
    write(A), width([[A]], B, C), print(C), !.
width([[X|Y]|_], X, [X|Y]).
width([X|Y], A, C) :- 
    findall(D, prolonged(X, D), B), append(Y, B, F), !, width(F, A, C).
width([_,Y], A, B) :- 
    width(Y, A, B).
```
Поиск в глубину с итеративным погружением:
```prolog
solve(A, B, C, D) :- 
    solve_depth([A], B, C, D).
solve_depth([X|Y], X, [X|Y], 0).
solve_depth(C, A, B, M) :- 
    M>0, prolonged(C, N), M1 is M-1, solve_depth(N, A, B, M1).
solve(A, B, C) :- 
    int(Num), solve(A, B, C, Num).
solve(A, B) :- 
    write(A), solve(A, B, C), print(C), !.
int(1).
int(M) :- 
    int(M1), M is M1+1.
```
## Результаты

Поиск в глубину с итеративным погружением:
``` prolog 
?- solve(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']).
[b, b, b, _, w, w, w]
[b, b, b, w, _, w, w]
[b, b, _, w, b, w, w]
[b, _, b, w, b, w, w]
[b, w, b, _, b, w, w]
[b, w, b, w, b, _, w]
[b, w, b, w, b, w, _]
[b, w, b, w, _, w, b]
[b, w, _, w, b, w, b]
[_, w, b, w, b, w, b]
[w, _, b, w, b, w, b]
[w, w, b, _, b, w, b]
[w, w, b, w, b, _, b]
[w, w, b, w, _, b, b]
[w, w, _, w, b, b, b]
[w, w, w, _, b, b, b]
true
```

Поиск в глубину:
``` prolog
?- search_in_depth(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']).
[b, b, b, _, w, w, w]
[b, b, b, w, _, w, w]
[b, b, _, w, b, w, w]
[b, b, w, _, b, w, w]
[b, b, w, b, _, w, w]
[b, b, w, b, w, _, w]
[b, b, w, _, w, b, w]
[b, b, w, w, _, b, w]
[b, b, w, w, b, _, w]
[b, b, w, w, b, w, _]
[b, b, w, w, _, w, b]
[b, b, w, _, w, w, b]
[b, b, _, w, w, w, b]
[b, _, b, w, w, w, b]
[b, w, b, _, w, w, b]
[b, w, b, w, _, w, b]
[b, w, b, w, w, _, b]
[b, w, b, w, w, b, _]
[b, w, b, w, _, b, w]
[b, w, b, _, w, b, w]
[b, w, _, b, w, b, w]
[b, _, w, b, w, b, w]
[_, b, w, b, w, b, w]
[w, b, _, b, w, b, w]
[w, b, b, _, w, b, w]
[w, b, b, w, _, b, w]
[w, b, b, w, b, _, w]
[w, b, b, w, b, w, _]
[w, b, b, w, _, w, b]
[w, b, b, _, w, w, b]
[w, b, _, b, w, w, b]
[w, _, b, b, w, w, b]
[_, w, b, b, w, w, b]
[b, w, _, b, w, w, b]
[b, w, w, b, _, w, b]
[b, w, w, b, w, _, b]
[b, w, w, b, w, b, _]
[b, w, w, b, _, b, w]
[b, w, w, _, b, b, w]
[b, w, _, w, b, b, w]
[b, _, w, w, b, b, w]
[_, b, w, w, b, b, w]
[w, b, _, w, b, b, w]
[w, b, w, _, b, b, w]
[w, b, w, b, _, b, w]
[w, b, w, b, b, _, w]
[w, b, w, b, b, w, _]
[w, b, w, b, _, w, b]
[w, b, w, b, w, _, b]
[w, b, w, _, w, b, b]
[w, b, w, w, _, b, b]
[w, b, w, w, b, _, b]
[w, b, w, _, b, w, b]
[w, b, _, w, b, w, b]
[w, _, b, w, b, w, b]
[_, w, b, w, b, w, b]
[b, w, _, w, b, w, b]
[b, w, w, _, b, w, b]
[b, w, w, w, b, _, b]
[b, w, w, w, _, b, b]
[b, w, w, _, w, b, b]
[b, w, _, w, w, b, b]
[b, _, w, w, w, b, b]
[_, b, w, w, w, b, b]
[w, b, _, w, w, b, b]
[w, _, b, w, w, b, b]
[w, w, b, _, w, b, b]
[w, w, b, w, _, b, b]
[w, w, _, w, b, b, b]
[w, w, w, _, b, b, b]
true
```
Поиск в ширину:
``` prolog
?- search_in_width(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']).
[b, b, b, _, w, w, w]
[b, b, b, w, _, w, w]
[b, b, _, w, b, w, w]
[b, _, b, w, b, w, w]
[b, w, b, _, b, w, w]
[b, w, b, w, b, _, w]
[b, w, b, w, b, w, _]
[b, w, b, w, _, w, b]
[b, w, _, w, b, w, b]
[_, w, b, w, b, w, b]
[w, _, b, w, b, w, b]
[w, w, b, _, b, w, b]
[w, w, b, w, b, _, b]
[w, w, b, w, _, b, b]
[w, w, _, w, b, b, b]
[w, w, w, _, b, b, b]
true
```

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-------------------|--------------|---------------|
| В глубину |  70            | 10.559 seconds |
| В ширину  |  16            | 1.894 seconds  |
| ID        |  16            | 0.498 seconds  |

## Выводы
Научилась реализовывать методы поиска в глубину, ширину и в глубину с итеартивным погружением, также научилась решать задачи поиска пути с помощью алгоритмов поиска, также научилась оценивать сложность и затраты памяти алгоритмов в языке Prolog.
Самым эффективным оказался поиск с итеративным погружением. Для нахождения кратчайшего пути нужно использовать поиск в ширину, если же нам важна память - поиск в глубину. Нужно помнить, что поиск в ширину может произойти не по короткому пути, если путей решения в программе будет гораздо больше, так как очередь путей будет расти в геометрической прогрессии. 
Так как Prolog для пути решения использует поиск в глубину - этот метод является самым простым в реализации. 




